# DailyLogs

![](비모.gif)

*done is better than perfect, 初志貫徹*

그날그날 공부한 내용을 추려서 올립니다. TIL은 프라이빗 레포로 관리합니다. 충분히 이해한 내용, 나누고 싶은 내용은 [네이버 블로그](https://blog.naver.com/PostList.naver?blogId=pty115&from=postList&categoryNo=71)에 올리고 있습니다.

#### :runner: on-going

- 과제평가 대비 
- 알고리즘/SQL 문제풀이
- Java8, 11 (~2월)

#### :fist_oncoming: hold

- Kotlin/Android (~1월)

- CS지식 구술평가 대비 (~12월말)

## Contents

#### 21/12/22 SQL문제풀이, URL/URI란, 운영체제 개념복습

- ANSI SQL은 DBMS 종류에 제약을 받지 않는다.
  - [친절한 SQL 튜닝 - YES24](http://www.yes24.com/Product/Goods/61254539)(오라클DB)
  - [Real MySQL - YES24](http://www.yes24.com/Product/Goods/6960931)

- [URI,URL,URN](https://github.com/CodingInterviewStudy/CrackingTheCodingInterview/wiki/7주차-2) : 이전에는 `naver.com/main.html`과 같이 웹사이트 리소스를 위치로(URL/URI) 불러오는 방식이었으나, 최근에는 Restful을 추구하며 `naver.com/main`으로 구분자를 통해(URI) 불러온다.
  - ![img](https://camo.githubusercontent.com/99a24e41700a0c2deeaf357291cfd916d518399454f72dca6e0b43ba35b149dc/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6779316776716d3938767471376a3630626a30366d30737630322e6a7067)

- 페이지교체 알고리즘
  - LRU 가장 오랫동안 참조되지 않은 페이지를 교체
  - LFU 참조횟수가 가장 적은 페이지를 교체, 왜냐하면 초기에 집중적으로 참조한 페이지는 더 필요하지 않을 수 있으므로
  - MFS 참조횟수가 가장 많은 페이지를 교체, 왜냐하면 참조횟수가 적으면 최근에 불러와 사용중인 페이지일 수 있으므로

#### 21/12/21 페이지교체 알고리즘, 단편화, 캐시 지역성에 대해 복습했다.

깊이 들어가면 끝이 없다. 개념 복습으로 마무리하고, 개발에 어떻게 활용할지 고민하면서 더 파고 들어가야 하겠다.

#### 21/12/20 프로세스, 멀티 프로세스, 프로세스 스케줄링에 대해 복습했다.

#### 21/12/19 자바 스트림 filter, collect 등 메서드 사용법을 복습했다.

#### 21/12/18 SQL SELECT문 관련내용을 정리했다.

SET 변수, WITH RECURSIVE, GROUP BY, 문법/실행순서, DATE_FORMAT, 컬럼/테이블 별칭, 테이블 조인 연산, WHERE, IF ELSE, LIMIT, SUBSTR

#### 21/12/17 자바 스트림에서 다양한 리듀스 연산을 수행할 수 있다. 프로그래머스 SQL 고득점 Kit를 완주했다!

- 자바 스트림 누적자 리듀싱 연산

  - 이미 정의된 리듀싱 : counting 등

  - 범용 리듀싱 : reducing

  - 그룹핑 : groupingBy

  - 누적자 : collect

- 프로그래머스 SQL Kit 완주!

#### 21/12/16 자바 컬렉션 객체에 스트림을 사용해 DB 쿼리처럼 다양한 작업을 할 수 있다.

스트림 메서드는 중간연산, 최종연산으로 나뉜다. 최종연산은 스트림 객체를 반환하지 않고, 중간연산은 스트림 객체를 반환한다. 중간연산은 최종연산을 만나야만  작업을 시작한다(루프퓨전, 쇼트서킷 등 포함.) 

#### 21/12/15 객체지향 SOLID : '추상성'을 최대한 유지하기 위해 '다형성'을 활용한다.

- Single Responsibility Principle 단일책임의 원칙 : 하나의 클래스는 하나의 책임을 가져야 하며, 변경이 있을 때 파급효과가 적도록 해야 한다.
- Open/closed Principle 개방-폐쇄의 원칙 : 확장에는 열려있되 변경에는 닫혀있어야 한다. 이를테면 객체의 멤버변수를 클래스 대신 인터페이스로 선언하면, 상황에 맞춰 해당 인터페이스를 구현한 클래스를 사용할 수 있다.
- Liskov Substitution Principle 리스코프 치환의 원칙 : 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상 동작해야 한다. 
- Interface Segregation Principle 인터페이스 분리의 원칙 : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- Dependency Inversion Principle 의존관계 역전 원칙 : 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다. 구현 클래스에 의존하지 말고 인터페이스에 의존해야 한다. 

#### 21/12/12 자바 스트림은 연산을 연속/병렬 처리하는 API이다.

컬렉션은 모든 데이터를 메모리에 올려 한 번에 처리한다. 스트림은 처리할 데이터만 메모리에 올려 처리한다. 컬렉션, 배열, 표준 입출력 등을 스트림화할 수 있는데, 스트림화는 비싼 연산이다. 

#### 21/12/11 자바 람다는 익명클래스를 단순화한 것이다. 

- `(인수목록) -> 표현식`
- `(인수목록) -> {코드블록;}`

#### 21/12/08 시스템 테스팅 면접문제도 면접관과 의사소통이 중요하다.

1)사용자와 사용목적을 확인 2)면접관과 의사소통하며 사용하는 경우의수 추려내기 3)한계조건을 확인 4)스트레스 조건과 장애조건을 확인 5)테스트 종류가 블랙박스/화이트박스 무엇인지, 사람의 개입이 필요한 테스트인지 확인

#### 21/12/07 시스템 디자인 설계 면접문제는 면접관과 의사소통이 중요하다.

문제를 정확히 정의하고, 작은 규모의 시스템에서 더 큰 규모로 점증적으로 확대해 나가자. 가정을 할 때는 명확히 언급하면 혹시 문제를 잘못 이해했을 때 면접관이 바로잡아줄 수 있다. 

#### 21/12/05 동작을 파라미터화해 객체지향 패러다임을 유지할 수 있다.

이를테면 컬렉션에서 어떤 데이터를 추출해야 하는데, 요구사항이 상황에 따라 시시때때로 변한다고 가정해보자. 보다 간결한 코드를 위해 프리디케이트, 익명클래스, 람다, 제네릭 등을 활용해 데이터 처리 함수를 바깥에서 구현, 매개인자로 넘겨 처리할 수 있다.

#### 21/12/03 백준에서 크루스칼 알고리즘 문제를 풀다.

- [1197번: 최소 스패닝 트리 (acmicpc.net)](https://www.acmicpc.net/problem/1197)
- [2406번: 안정적인 네트워크 (acmicpc.net)](https://www.acmicpc.net/problem/2406) 메모리초과로 고심하다 `Scanner` 대신 `BufferedReader`를 사용해 해결

#### 21/12/02 소프티어 모의 알고리즘 대회에 참가, 크루스칼 알고리즘을 짜지 못하다.

1)간선(정점A, 정점B, 가중치) 리스트로 구성한다. 2)오름차순으로 정렬한다. 3)union-find함수를 이용해 disjoing-set을 수행한다. 

#### 21/12/01 최소공통조상트리는 깊이우선탐색을 활용한다.

1)트리를 구성한다. 2)노드는 부모/자식/깊이 정보를 가지고 있다. 3)임의의 노드를 선택해 루트노드를 찾는다. 4)루트노드로부터 깊이우선탐색을 실시하고 깊이 정보를 갱신한다. 5)주어진 두 개 노드의 깊이를 맞춘다. 6)두 노드가 같아지면 결과값을 출력하고 종료한다. 

#### 21/11/30 자바8은 함수형 패러다임을 일부 수용했다.

자바8 이후로는 보다 간결하게 코드를 작성하고, 보다 쉽게 멀티코어 프로세서를 활용할 수 있다. 이를테면 컬렉션 객체에서 데이터를 추출/정렬할 때, 메서드 체이닝과 람다 표현식으로 보다 자연어에 가깝게 서술할 수 있다. 또한 대용량 데이터의 경우 StreamAPI를 활용해 병렬작업을 추상화해 수행할 수 있다.